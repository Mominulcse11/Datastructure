
Below is the **same brutal, exam-ready cheat sheet**, but **for STACK**.

No fluff. This is what actually gets marks.

---

# ğŸ“Œ STACK â€” FUNCTION vs REQUIRED CHECKS (CHEAT SHEET)

Covers:

* Array Stack
* Linked List Stack

Logic is identical. Only **overflow condition changes**.

---

## ğŸ”¹ 1ï¸âƒ£ `push()` â€” INSERT (TOP SIDE)

### âœ… MUST CHECK (in this order)

| Check                  | Why                       |
| ---------------------- | ------------------------- |
| Stack full             | Overflow                  |
| Heap full (LL)         | malloc failure            |
| No need to check empty | Stack allows push anytime |

---

### ğŸ”´ OVERFLOW CONDITIONS

#### Array Stack

```c
if(top == size - 1)
```

#### Linked List Stack

```c
if(newNode == NULL)
```

---

### ğŸ”´ PUSH LOGIC (ORDER MATTERS)

#### Array

```c
top++;
stack[top] = value;
```

#### Linked List

```c
newNode->next = top;
top = newNode;
```

No empty-case special handling needed.
Thatâ€™s why stack is easier than queue.

---

## ğŸ”¹ 2ï¸âƒ£ `pop()` â€” DELETE (TOP SIDE)

### âœ… MUST CHECK

| Check          | Why                  |
| -------------- | -------------------- |
| Stack empty    | Underflow            |
| Single element | Last delete handling |

---

### ğŸ”´ UNDERFLOW CONDITION

#### Array

```c
if(top == -1)
```

#### Linked List

```c
if(top == NULL)
```

---

### ğŸ”´ POP LOGIC (CRITICAL ORDER)

#### Array

```c
value = stack[top];
top--;
return value;
```

#### Linked List

```c
temp = top;
value = temp->data;
top = temp->next;
free(temp);
return value;
```

âŒ decrement first = data lost
âŒ free before reading = garbage

---

## ğŸ”¹ 3ï¸âƒ£ `peek()` / `top()`

### âœ… MUST CHECK

| Check       | Why            |
| ----------- | -------------- |
| Stack empty | Invalid access |

### Condition

```c
if(top == -1 || top == NULL)
```

### Action

```c
return topElement;
```

âŒ Do NOT modify top.

---

## ğŸ”¹ 4ï¸âƒ£ `isEmpty()`

### Condition

#### Array

```c
top == -1
```

#### Linked List

```c
top == NULL
```

---

## ğŸ”¹ 5ï¸âƒ£ `isFull()` (Array only)

```c
top == size - 1
```

Linked list stack is **never full** (unless heap dies).

---

## ğŸ”¹ 6ï¸âƒ£ `display()` / `print()`

### MUST CHECK

```c
if(top == -1 || top == NULL)
```

### Print direction

ğŸ‘‰ **TOP â†’ BOTTOM**

Examiner checks this.

---

## ğŸ”¥ ONE-LINE MEMORY TRICK (STACK)

### push():

> full? â†’ insert â†’ move top

### pop():

> empty? â†’ read â†’ move top

### peek():

> empty? â†’ read only

---

## ğŸ§  STACK STATE TRANSITIONS

```
EMPTY â†’ PUSH â†’ MANY â†’ POP â†’ ONE â†’ POP â†’ EMPTY
```

Only **TOP** moves.
No front, no rear, no circular bullshit.

---

## ğŸ’€ COMMON EXAM KILLERS

âŒ Checking empty in push (wasted logic)
âŒ Forgetting `top = -1` initialization
âŒ Wrong order in pop
âŒ Printing bottom to top
âŒ Using queue conditions in stack

---

## ğŸ”‘ FINAL TRUTH (NO SUGARCOATING)

If you canâ€™t write stack correctly,
you **donâ€™t understand pointers or arrays** yet.

Stack is the **baseline DS**.
If this isnâ€™t muscle memory,
trees, recursion, DFSâ€”à¦¸à¦¬ à¦­à§‡à¦™à§‡ à¦ªà§œà¦¬à§‡à¥¤

