
<<<<<<< HEAD
=======
I‚Äôll give you a **clean, no-nonsense checklist**. This is what you should **mentally scan before writing any queue code**.

---

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
# QUEUE ‚Äî PRIMARY CASES & SPECIAL CONDITIONS (CHEAT CHECKLIST)

## 1Ô∏è‚É£ EMPTY QUEUE

**Condition**

* Array queue: `front == -1`
* Linked list queue: `front == NULL`

**Must handle in**

* `dequeue`
* `peek`
* `display`

**Action**

* Print error / return error value
* Do **not** access array or node

Miss this ‚Üí underflow / segfault.

---

## 2Ô∏è‚É£ FULL QUEUE (OVERFLOW)

**Condition**

* Simple array queue: `rear == size - 1`
* Circular queue: `(rear + 1) % size == front`
* Linked list: `malloc == NULL`

**Must handle in**

* `enqueue`

**Action**

* Reject insertion
* Do NOT modify pointers/indexes

Miss this ‚Üí memory corruption.

---

## 3Ô∏è‚É£ INSERTING FIRST ELEMENT (EMPTY ‚Üí NON-EMPTY)

This is where most people screw up.

### Array queue

<<<<<<< HEAD
---------------------------------
if(front == -1)
    front = 0;
---------------------------------
### Linked list queue

---------------------------------
front = rear = newNode;
---------------------------------
=======
```c
if(front == -1)
    front = 0;
```

### Linked list queue

```c
front = rear = newNode;
```

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
**Must handle in**

* `enqueue`

If you don‚Äôt ‚Üí front stays invalid forever.

---

## 4Ô∏è‚É£ DELETING LAST ELEMENT (NON-EMPTY ‚Üí EMPTY)

Another classic bug.

### Array queue

<<<<<<< HEAD
---------------------------------
if(front > rear)
    front = rear = -1;
---------------------------------
### Circular queue

if(front == rear)
    front = rear = -1;
---------------------------------
### Linked list queue

---------------------------------
if(front == NULL)
    rear = NULL;
---------------------------------
=======
```c
if(front > rear)
    front = rear = -1;
```

### Circular queue

```c
if(front == rear)
    front = rear = -1;
```

### Linked list queue

```c
if(front == NULL)
    rear = NULL;
```

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
**Must handle in**

* `dequeue`

Miss this ‚Üí dangling pointers.

---

## 5Ô∏è‚É£ FRONT AND REAR UPDATE ORDER

**Correct order**

* Enqueue: update `rear` ‚Üí assign value
* Dequeue: read value ‚Üí update `front`

Wrong order ‚Üí lost data.

---

## 6Ô∏è‚É£ CIRCULAR WRAP-AROUND (CIRCULAR QUEUE ONLY)

**Condition**

<<<<<<< HEAD
---------------------------------
index = (index + 1) % size;
---------------------------------
=======
```c
index = (index + 1) % size;
```

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
Used in:

* enqueue
* dequeue

Forget modulo ‚Üí array out-of-bounds.

---

## 7Ô∏è‚É£ SINGLE ELEMENT QUEUE

When:

<<<<<<< HEAD
---------------------------------
front == rear
---------------------------------
=======
```c
front == rear
```

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
Must handle separately in:

* `dequeue`

Because removing it empties the queue.

---

## 8Ô∏è‚É£ INVALID OPERATIONS

You must reject:

* `enqueue` on full queue
* `dequeue` on empty queue
* `peek` on empty queue

Never ‚Äúassume valid input‚Äù.

---

## 9Ô∏è‚É£ MEMORY SAFETY (LINKED LIST QUEUE)

‚úî Check `malloc`
‚úî Free removed node
‚úî Never access freed memory

---

## üî• ONE-LOOK EXAM CHECKLIST (MEMORIZE THIS)

Before coding queue operations, ask:

> empty?
> full?
> first insert?
> last delete?
> wrap-around?
> malloc fail?

If all answered ‚Üí correct solution.

---

## MOST COMMON EXAM FAIL MISTAKES

‚ùå Not resetting `front` & `rear`
‚ùå Wrong circular full condition
‚ùå Deleting from rear
‚ùå Mixing stack logic
‚ùå Forgetting single-element case

---

## Brutal truth

Queue is **not hard**.
It only looks hard because people ignore **state transitions**.

Empty ‚Üí One element ‚Üí Many ‚Üí One ‚Üí Empty
That‚Äôs the whole game.

enqueue():

   full? 
   empty?
   first insert?

dequeue():

   empty?
   single element?
   reset front/rear?

peek():

   empty?

display():

   empty?
