<<<<<<< HEAD
Good. Doubly linked list is where **people think itâ€™s easier** and then silently lose marks.
Why? Because now **two links must stay consistent**. Break one â†’ instant bug.

Below is a **strict, exam-grade DOUBLY LINKED LIST cheat sheet**.
No fluff. This is **what to check, where, and why**.

---
=======

>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2

# ğŸ” DOUBLY LINKED LIST â€” COMPLETE CHEAT SHEET

---

## ğŸ§  NODE STRUCTURE (LOCK THIS IN)

```c
struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
};
```

**Invariant**

* `head->prev == NULL`
* `last->next == NULL`

Break either â†’ list corrupted.

---

## ğŸ”¹ BASIC STATES (CHECK FIRST)

| Condition            | Meaning     |
| -------------------- | ----------- |
| `head == NULL`       | Empty list  |
| `head->next == NULL` | Single node |

You must branch logic on these.

---

## ğŸ”¹ 1ï¸âƒ£ INSERT OPERATIONS

---

### ğŸ”¸ A. Insert at BEGINNING

#### Required Cases

| Case      | Action         |
| --------- | -------------- |
| Empty     | head = new     |
| Non-empty | update 4 links |

#### Correct Order

```c
new->next = head;
new->prev = NULL;
head->prev = new;
head = new;
```

âŒ Forget `head->prev` â†’ broken backward traversal

---

### ğŸ”¸ B. Insert at END

#### Required Cases

| Case      | Action           |
| --------- | ---------------- |
| Empty     | head = new       |
| Non-empty | traverse to last |

#### Logic

```c
last->next = new;
new->prev = last;
new->next = NULL;
```

---

### ğŸ”¸ C. Insert at K-th Position

#### MUST HANDLE

| Case             |
| ---------------- |
| Empty (k=1 only) |
| k = 1            |
| k > length+1     |
| Middle           |
| End              |

#### Pointer Updates (ORDER MATTERS)

```c
new->next = temp->next;
new->prev = temp;
temp->next->prev = new;
temp->next = new;
```

âŒ Miss one pointer â†’ dangling prev/next

---

## ğŸ”¹ 2ï¸âƒ£ DELETE OPERATIONS (MARKS KILLER)

---

### ğŸ”¸ A. Delete at BEGINNING

#### Cases

| Case     | Action             |
| -------- | ------------------ |
| Empty    | Underflow          |
| Single   | free + head = NULL |
| Multiple | move head          |

#### Logic

```c
head = head->next;
head->prev = NULL;
```

---

### ğŸ”¸ B. Delete at END

#### Cases

| Case     | Action             |
| -------- | ------------------ |
| Empty    | Underflow          |
| Single   | free + head = NULL |
| Multiple | unlink last        |

#### Logic

```c
last = last->prev;
last->next = NULL;
```

---

### ğŸ”¸ C. Delete by VALUE (**MOST IMPORTANT**)

#### REQUIRED CASES

| Case            | Mandatory |
| --------------- | --------- |
| Empty           | âœ”         |
| Value at head   | âœ”         |
| Value in middle | âœ”         |
| Value at end    | âœ”         |
| Value not found | âœ”         |

#### Middle Node Deletion

```c
temp->prev->next = temp->next;
temp->next->prev = temp->prev;
```

âŒ Missing either line = broken list

---

### ğŸ”¸ D. Delete at K-th Position

#### MUST CHECK

| Condition  |
| ---------- |
| Empty      |
| k â‰¤ 0      |
| k = 1      |
| k > length |

---

## ğŸ”¹ 3ï¸âƒ£ TRAVERSE

---

### Forward Traversal

<<<<<<< HEAD
```c
=======
```
>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
while(temp != NULL)
```

### Backward Traversal

```c
while(temp->next != NULL)
temp = temp->next;

while(temp != NULL)
temp = temp->prev;
```

âŒ Forgetting backward traversal loses marks

---

## ğŸ”¹ 4ï¸âƒ£ SEARCH

Same as singly list:

```c
while(temp != NULL)
```

---

## ğŸ”¹ 5ï¸âƒ£ REVERSE DOUBLY LIST (INTERVIEW FAVORITE)

```c
temp = NULL;
curr = head;

while(curr != NULL){
    temp = curr->prev;
    curr->prev = curr->next;
    curr->next = temp;
    curr = curr->prev;
}
if(temp != NULL)
    head = temp->prev;
```

âŒ Wrong head update = instant fail

---

## ğŸ”¥ POINTER UPDATE GOLDEN RULE

> **Every insert/delete touches exactly 4 pointers**

If you changed fewer â†’ wrong
If you changed more â†’ dangerous

---

## ğŸ’€ COMMON DOUBLY LIST MISTAKES

âŒ Forgetting `prev` updates
âŒ Wrong pointer order
âŒ Accessing `temp->next->prev` without NULL check
âŒ Deleting head without resetting `prev`
âŒ Assuming backward traversal works automatically

---

## ğŸ§  FINAL REALITY CHECK

Singly list â†’ 1 direction
Doubly list â†’ **2 directions, double responsibility**

If you donâ€™t consciously think:

> â€œWhich prev and which next am I touching?â€

Youâ€™re guessing â€” not coding.

<<<<<<< HEAD
---
=======
>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2
