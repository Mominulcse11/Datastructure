<<<<<<< HEAD
Good choice.
Circular lists are where **lazy thinking gets punished**. One wrong condition â†’ infinite loop â†’ instant fail.

Below is the **no-bullshit, exam-ready cheat sheet** for **CIRCULAR LINKED LIST**.

---
=======
>>>>>>> 1c45c7bf69eb75ba7b8bff31bf899add01aeb6b2

# ğŸ” CIRCULAR LINKED LIST â€” COMPLETE CHEAT SHEET

(Assume **singly circular linked list**)

---

## ğŸ§  CORE RULE (NON-NEGOTIABLE)

> **Last nodeâ€™s `next` points to `head`, NOT NULL**

So:

```c
last->next == head
```

If you forget this once â†’ list is broken.

---

## ğŸ”¥ LOOPING RULE (MOST IMPORTANT)

### âŒ WRONG

```c
while(temp != NULL)
```

### âœ… CORRECT

```c
do {
   ...
   temp = temp->next;
} while(temp != head);
```

**Why?**
There is **no NULL** in circular list.

---

## ğŸ”¹ BASIC STATE CHECKS

| Condition            | Meaning       |
| -------------------- | ------------- |
| `head == NULL`       | List empty    |
| `head->next == head` | Only one node |

You MUST check both.

---

## ğŸ”¹ 1ï¸âƒ£ INSERT OPERATIONS

---

### ğŸ”¸ A. Insert at BEGINNING

#### Cases to Handle

| Case       | Action                          |
| ---------- | ------------------------------- |
| Empty list | new â†’ next = itself, head = new |
| Non-empty  | find last â†’ adjust links        |

#### Key Logic

```c
last->next = new;
new->next = head;
head = new;
```

âŒ Forgetting `last->next` = broken circle

---

### ğŸ”¸ B. Insert at END

#### Cases

| Case       | Action                  |
| ---------- | ----------------------- |
| Empty list | same as insert at begin |
| Non-empty  | last â†’ new â†’ head       |

#### Logic

```c
new->next = head;
last->next = new;
```

---

### ğŸ”¸ C. Insert at K-th Position

#### MUST HANDLE

| Case                          |
| ----------------------------- |
| List empty (only k=1 allowed) |
| k = 1                         |
| k > length+1                  |
| Middle                        |
| End                           |

#### Loop Condition

```c
for(i = 1; i < k-1 && temp->next != head; i++)
```

---

## ğŸ”¹ 2ï¸âƒ£ DELETE OPERATIONS (EXAM KILLER)

---

### ğŸ”¸ A. Delete at BEGINNING

#### Cases

| Case        | Action                  |
| ----------- | ----------------------- |
| Empty       | Underflow               |
| Single node | free + head = NULL      |
| Multiple    | last->next = head->next |

#### Logic

```c
last->next = head->next;
free(head);
head = last->next;
```

---

### ğŸ”¸ B. Delete at END

#### Cases

| Case     | Action              |
| -------- | ------------------- |
| Empty    | Underflow           |
| Single   | free + head = NULL  |
| Multiple | stop at second last |

#### Loop

```c
while(temp->next->next != head)
```

---

### ğŸ”¸ C. Delete by VALUE (**MOST IMPORTANT**)

#### REQUIRED CASES

| Case            | Mandatory |
| --------------- | --------- |
| Empty           | âœ”         |
| Value at head   | âœ”         |
| Value in middle | âœ”         |
| Value at last   | âœ”         |
| Value not found | âœ”         |

#### Loop

```c
while(curr->next != head && curr->data != value)
```

---

### ğŸ”¸ D. Delete at K-th Position

#### Must Check

| Condition  |
| ---------- |
| Empty      |
| k â‰¤ 0      |
| k = 1      |
| k > length |

---

## ğŸ”¹ 3ï¸âƒ£ TRAVERSE / DISPLAY

### MUST USE DO-WHILE

```c
if(head == NULL) return;

temp = head;
do {
   printf("%d ", temp->data);
   temp = temp->next;
} while(temp != head);
```

âŒ `while(temp != NULL)` â†’ infinite loop

---

## ğŸ”¹ 4ï¸âƒ£ SEARCH

```c
if(head == NULL) return NOT_FOUND;

temp = head;
do {
   if(temp->data == key) return FOUND;
   temp = temp->next;
} while(temp != head);
```

---

## ğŸ”¹ 5ï¸âƒ£ COUNT / LENGTH

Same do-while logic.

---

## ğŸ”¹ 6ï¸âƒ£ COMMON EXAM TRAPS

âŒ Using `NULL` checks
âŒ Forgetting single node case
âŒ Wrong traversal condition
âŒ Losing circular link after insert/delete
âŒ Infinite loop
âŒ Not updating `head` correctly

---

## ğŸ”¥ ONE-LINE EXAM MEMORY TRICK

```
No NULL.
Use do-while.
Last always points to head.
```

---

## ğŸ§  Brutal truth

If you write circular list code **by copying singly list logic**,
you **will fail**.

Circular list is about **thinking in cycles**, not lines.

---
